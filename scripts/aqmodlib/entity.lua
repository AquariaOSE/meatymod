local registry = rawget(_G, "_entity_registry_")local existing = rawget(_G, "_entity_existing_")local lastMapName = ""if not registry then    registry = {}    existing = {}    rawset(_G, "_entity_registry_", registry)    rawset(_G, "_entity_existing_", existing)end-- Runs a function for all entites. Returns true if processing was stopped early.-- * f:      function to run. once it returns true, stop processing.-- * param:  passed as additional parameter, as in f(entity, param)-- * filter: if given, f will only be called if filter(entity, fparam) returns true-- * fparam: passed to the filter functionlocal function forAllEntities(f, param, filter, fparam)    local e = getFirstEntity()    local nx = getNextEntity    if not filter then        while e ~= 0 do            if f(e, param) == true then                return true            end            e = nx()        end    elseif type(filter) == "string" then        while e ~= 0 do            if entity_isName(e, filter) then                if f(e, param) == true then                    return true                end            end            e = nx()        end    else        while e ~= 0 do            if filter(e, fparam) then                if f(e, param) == true then                    return true                end            end            e = nx()        end    end    return falseend-- returns a table[1..n] with all entites, optionally matching a given filter function-- * filter: if given, the entity will only be included if filter(entity, fparam) returns true-- * fparam: passed to the filter functionlocal function getAllEntities(filter, fparam)    local e = getFirstEntity()    local tab = {}    local ins = table.insert    local nx = getNextEntity    if not filter then        while e ~= 0 do            ins(tab, e)            e = nx()        end    else        while e ~= 0 do            if filter(e, fparam) then                ins(tab, e)            end            e = nx()        end    end    return tabendlocal function entity_disable(e)    entity_alpha(e, 0)    entity_setUpdateCull(e, 0)    entity_setEntityType(e, ET_NEUTRAL)    esetv(e, EV_LOOKAT, false)    entity_setAllDamageTargets(e, false)    entity_setPosition(e, 0, 0)end-- this function needs a bit of explanation.-- if using many trigger entities, they usually stick to naija's position.-- the problem is that these break the head rotation/smile, because the game-- searches for any entity within a distance of 800, and focuses that if it has EV_LOOKAT set.-- if this is not set, NO other entity is chosen.-- but because song related callbacks need a distance of 1000 or smaller to be called,-- the triggers can't be too far away.-- basically, using this function reduces usage of magic numbers everywhere.-- [Intended to be called from init() !!]local function entity_makePassive(me)    entity_setEntityType(me, ET_NEUTRAL) -- by making the entity neutral, normal shots won't target this    esetv(me, EV_LOOKAT, 0)    entity_setAllDamageTargets(me, false)    entity_setUpdateCull(me, -1)    entity_setCanLeaveWater(me, true)    entity_setEntityLayer(me, -100) -- LR_ENTITIES00 - Avatar::updateLookAt() searches only for entities in [LR_ENTITIES0 .. LR_ENTITIES2]    entity_setInvincible(me, true)    entity_setBeautyFlip(me, false)    entity_setCollideRadius(me, 0)end-- assign an arbitrarily named value to an entitylocal function entity_registrySet(e, i, val)    if not e or e == 0 then return end    local t = registy[e]    if t then        t[i] = val    else        registry[e] = { [i] = val }    endend-- get a named value for an entitylocal function entity_registryGet(e, i)    local t = registy[e]    if t then        return t[i]    endendlocal function entity_faceRight(e)    if not entity_isfh(e) then        entity_fh(e)    endendlocal function entity_faceLeft(e)    if entity_isfh(e) then        entity_fh(e)    endendlocal function entity_fhToX(e, x)    if x < entity_x(e) then        entity_faceLeft(e)    else        entity_faceRight(e)    endendlocal function entity_markExisting(e)    if e ~= 0 then        existing[e] = true    endendlocal function entity_markDeleted(e)    existing[e] = nilendlocal function entity_exists(e)    -- HACK: THIS IS SLOW, FIX ASAP! IMPORTANT!    if not MOD_RELEASE_VERSION then        for _, c in pairs(getAllEntities()) do            if e == c then                return true            end        end    end        return existing[e] -- <<-- this needs to be fixed. see globalhacks.end-- returns: bool, x, y (last checked position or where it hit an obstruction)local function entity_isLineToEntityObstructed(me, e)    local startx, starty = entity_getPosition(me)    local endx, endy = entity_getPosition(e)    return isLineObstructed(startx, starty, endx, endy)endlocal function entity_isInLineOfSight(me, e)    return not entity_isLineToEntityObstructed(me, e)end-- offs is additional angle to add: +x to look down by x more angles, -x to look uplocal function entity_getHeadLookVector(e, head, offs)    local nx, ny = bone_getNormal(head)    if not offs then offs = 0 end    if entity_isfh(e) then        -- facing right        nx, ny = vector_perpendicularLeft(nx, ny)        nx, ny = vector_rotateDeg(nx, ny, offs) -- positive: rotate right -> rotate down    else        -- facing left        nx, ny = vector_perpendicularRight(nx, ny)        nx, ny = vector_rotateDeg(nx, ny, -offs) -- -> made negative: rotate right -> rotate up    end    return nx, nyendlocal function entity_canSeePoint(e, head, px, py, maxdist, angleUp, angleDown, offs)        local headx, heady = bone_getWorldPosition(head)    if not angleUp   then angleUp   = 30 end    if not angleDown then angleDown = 30 end        -- first check - point nearby?    local dx, dy = makeVector(headx, heady, px, py)    if maxdist and vector_getLength(dx, dy) > maxdist then        return false    end        -- second check - in arc?    local lookx, looky = entity_getHeadLookVector(e, head, offs)    if not isPointInArc(headx, heady, lookx, looky, angleUp, angleDown, px, py) then        return false    end        -- last check - obstructed / behind a wall?    return not isLineObstructed(headx, heady, px, py)endlocal function entity_canSeeEntity(e, head, who, maxdist, v, offs)    local x, y = entity_getPosition(who)    return entity_canSeePoint(e, head, x, y, maxdist, angle, offs)endlocal function cleanupRegistry()    local r = registry    local mapname = getMapName()    registry = {}    existing = {}    rawset(_G, "_entity_registry_", registry)    rawset(_G, "_entity_existing_", registry)            local alle = getAllEntities()    for _, e in pairs(alle) do        existing[e] = true    end        -- HACK: if the cleanup happens errorneously during the game, without reloading the map.    -- this is not 100% safe on map reload, but should do the job.    -- basically, there is a VERY SLIGHT possibility that an entity that is created will have the same pointer    -- of a previously existing entity.    -- anyway, who cares.    if mapname == lastMapName then        -- copy over values of those entities that still exist        for _, e in pairs(alle) do            local val = r[e]            if val then                registry[e] = val            end        end    end            lastMapName = mapnameendmodlib_onClean(cleanupRegistry)return {    forAllEntities = forAllEntities,    getAllEntities = getAllEntities,    entity_canSeePoint = entity_canSeePoint,    entity_canSeeEntity = entity_canSeeEntity,    entity_disable = entity_disable,    entity_exists = entity_exists,    entity_faceLeft = entity_faceLeft,    entity_faceRight = entity_faceRight,    entity_fhToX = entity_fhToX,    entity_getHeadLookVector = entity_getHeadLookVector,    entity_isLineToEntityObstructed = entity_isLineToEntityObstructed,    entity_isInLineOfSight = entity_isInLineOfSight,    entity_makePassive = entity_makePassive,    entity_markDeleted = entity_markDeleted,    entity_markExisting = entity_markExisting,    entity_registryGet = entity_registryGet,    entity_registrySet = entity_registrySet,}